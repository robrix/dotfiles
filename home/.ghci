:set +t
:set -package pretty-show -package hscolour -package process

:def! pretty \ _ -> pure "let colour = putStrLn Prelude.. Language.Haskell.HsColour.hscolour Language.Haskell.HsColour.TTY Language.Haskell.HsColour.Colourise.defaultColourPrefs Prelude.False Prelude.False \"\" Prelude.False Prelude.. Text.Show.Pretty.ppShow\n:set -interactive-print colour"

:def! no-pretty \ _ -> pure ":set -interactive-print System.IO.print"

:def! r \_ -> pure ":reload\n:pretty"

:seti -fbreak-on-error

:set -Wwarn

:set prompt-function \ ms _ -> do { cols <- read <$> System.Process.readProcess "tput" ["cols"] "" ; branch <- ("(" ++) . (++ ")") . init <$> System.Process.readProcess "git" ["symbolic-ref", "--short", "HEAD"] "" ; let { m = cols - length branch ; mns = Data.List.intercalate ", " ms } ; pure (Text.Printf.printf "\ESC[46m\STX%*s\r%s\ESC[m\STX\n\ESC[1;36m\STXλ \ESC[m\STX" cols branch (if length mns > m then take (m - 2) mns ++ "…" else mns)) }
